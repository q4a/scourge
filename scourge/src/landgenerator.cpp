/***************************************************************************
                landgenerator.cpp  -  Generates outdoor maps
                             -------------------
    begin                : Sat March 28, 2009
    copyright            : (C) 2009 by Gabor Torok
    email                : cctorok@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
#include "common/constants.h"
#include "landgenerator.h"
#include "render/map.h"
#include "shapepalette.h"
#include "scourge.h"
#include "board.h"
#include "render/maprender.h"
#include "render/maprenderhelper.h"
#include "render/glshape.h"
#include "render/virtualshape.h"
#include "sqbinding/sqbinding.h"
#include "rpg/rpglib.h"
#include "creature.h"
#include "render/texture.h"
#include <vector>

using namespace std;


/**
 * This generator generates a 296x296 (quarter) map. Before calling generate(), be sure to call setRegion().
 * 
 * A region is a 32x32 pixel section of the map bitmap. The map bitmap is broken into 128x128 pixel section.
 * (See: scourge_data/mapgrid/world/) There are 4x4 regions per bitmap grid (128/32). So for example, calling
 * setRegion( 6, 39 ) would load map_100.png ( (int)( 39 / 4 ) * 11 + (int)( 6 / 4 ) ). Then inside map_100.png, 
 * the region shown is 2, 1.
 * 
 * A Map object can thus contain 4 296x296 map section (since it's 592x592 units large) which is the max number
 * of sections seen by the player at one time. (If the player reaches the corner of one 296x296 section.) 
 * 
 * When the player reaches the corner, existing sections will be passivated (saved) and new ones will be loaded or 
 * generated by this class. The section(s) that remain in memory (drawn on the Map class) will be shuffled around. 
 * For example, when traveling north, the southern section will be passivated, the northern section becomes the southern
 * one and a new section is loaded/generated into the north part of the in-memory Map class.
 * 
 * Also remember to call setMapPosition() before calling generate to denote where in the map the new quarter
 * should get rendered to. The arguments to setMapPosition() are in OUTDOORS_STEP units (so, 75, 75 is the fourth quarter.)
 */
LandGenerator::LandGenerator( Scourge *scourge, int level, int depth, int maxDepth,
                              bool stairsDown, bool stairsUp,
                              Mission *mission ) :
		TerrainGenerator( scourge, level, depth, maxDepth, stairsDown, stairsUp, mission, 13 ) {
	// init the ground
	for ( int x = 0; x < QUARTER_WIDTH_IN_NODES; x++ ) {
		for ( int y = 0; y < QUARTER_DEPTH_IN_NODES; y++ ) {
			ground[x][y] = 0;
		}
	}
	this->cellular = new CellularAutomaton( QUARTER_WIDTH_IN_NODES, QUARTER_DEPTH_IN_NODES );
	
	this->regionX = this->regionY = 0;
	this->mapPosX = this->mapPosY = 0;
	this->willAddParty = false;
	this->bitmapIndex = -1;
	this->bitmapSurface = NULL;
}

LandGenerator::~LandGenerator() {
	delete cellular;
}


bool LandGenerator::drawNodes( Map *map, ShapePalette *shapePal ) {
	updateStatus( _( "Loading theme" ) );
	if ( map->getPreferences()->isDebugTheme() ) shapePal->loadDebugTheme();
	else shapePal->loadTheme( "outdoor" );

	map->setHeightMapEnabled( true );

	// add mountains
	for ( int x = 0; x < QUARTER_WIDTH_IN_NODES; x++ ) {
		for ( int y = 0; y < QUARTER_DEPTH_IN_NODES; y++ ) {
			if ( cellular->getNode( x, y )->wall ) {
				map->setGroundHeight( mapPosX + x, mapPosY + y, Util::roll( 14.0f, 20.0f ) );
			} else if ( cellular->getNode( x, y )->water ) {
				map->setGroundHeight( mapPosX + x, mapPosY + y, -Util::roll( 14.0f, 20.0f )	 );
			} else {
				map->setGroundHeight( mapPosX + x, mapPosY + y, ground[x][y] );
			}
		}
	}
	
	// event handler for custom map processing
	int params[8];
	params[0] = regionX;
	params[1] = regionY;
	params[2] = mapPosX * OUTDOORS_STEP;
	params[3] = mapPosY * OUTDOORS_STEP;
	bool ret = shapePal->getSession()->getSquirrel()->callIntArgMethod( "generate_land", 4, params );
	
	if( !ret ) {
		// add trees
		for ( int x = 0; x < QUARTER_WIDTH_IN_NODES; x++ ) {
			for ( int y = 0; y < QUARTER_DEPTH_IN_NODES; y++ ) {
				if ( !cellular->getNode( x, y )->water ) {
					
					GLShape *shape = shapePal->getRandomTreeShape( shapePal );
					int xx = ( mapPosX + x ) * OUTDOORS_STEP;
					int yy = ( mapPosY + y ) * OUTDOORS_STEP + shape->getHeight();
					
					if( !map->isRoad( xx, yy ) ) {
						
						params[4] = x * OUTDOORS_STEP;
						params[5] = y * OUTDOORS_STEP;
						params[6] = cellular->getNode( x, y )->climate;
						params[7] = cellular->getNode( x, y )->vegetation;
						shapePal->getSession()->getSquirrel()->callIntArgMethod( "generate_tree", 8, params );
		
		//					// don't put them on roads and in houses
		//					if ( map->shapeFitsOutdoors( shape, xx, yy, 0 ) ) {
		//						map->setPosition( xx, yy, 0, shape );
		//					}
					}
				}
			}
		}
		
		// create a set of rooms for outdoor items
		doorCount = 0;
		roomCount = 0;
		room[ roomCount ].x = mapPosX * OUTDOORS_STEP;
		room[ roomCount ].y = mapPosY * OUTDOORS_STEP;
		room[ roomCount ].w = QUARTER_WIDTH_IN_NODES * OUTDOORS_STEP;
		room[ roomCount ].h = QUARTER_DEPTH_IN_NODES * OUTDOORS_STEP;
		room[ roomCount ].valueBonus = 0;
		roomCount++;
		roomMaxWidth = 0;
		roomMaxHeight = 0;
		objectCount = 7 + ( level / 8 ) * 5;
		monsters = true;
	}

	return true;
}

MapRenderHelper* LandGenerator::getMapRenderHelper() {
	// we need fog
	return MapRenderHelper::helpers[ MapRenderHelper::OUTDOOR_HELPER ];
	//return MapRenderHelper::helpers[ MapRenderHelper::DEBUG_OUTDOOR_HELPER ];
}

// =====================================================
// =====================================================
// generation
//

// a 16x16 block of data (in four 8x8 sections, one per cellular section)
int data[ REGION_SIZE * REGION_SIZE ];
int climate[ REGION_SIZE * REGION_SIZE ];
int vegetation[ REGION_SIZE * REGION_SIZE ];

void printData() {
	cerr << "-----------------------------------" << endl;
	for( int y = 0; y < REGION_SIZE; y++ ) {
		for( int x = 0; x < REGION_SIZE; x++ ) {
			fprintf( stderr, " %2d", data[ y * REGION_SIZE + x ] );
		}
		fprintf( stderr, "\n" );
	}
}

void printRGB( vector<GLubyte> *image ) {
	for( int y = 0; y < REGION_SIZE; y++ ) {
		for( int x = 0; x < REGION_SIZE; x++ ) {
			int offs = y * REGION_SIZE * BYTES_PER_PIXEL + x * BYTES_PER_PIXEL;
			fprintf( stderr, " %02x%02x%02x", image->at( offs + 0 ), image->at( offs + 1 ), image->at( offs + 2 ) );
		}
		cerr << "\n";
	}
}	

void LandGenerator::loadMapGridBitmap() {
	// load the correct bitmap (if not already in memory)
	int bitmapX = regionX / REGIONS_PER_BITMAP;
	int bitmapY = regionY / REGIONS_PER_BITMAP;
	int bitmapIndex = bitmapY * BITMAPS_PER_ROW + bitmapX;
	cerr << "Needs bitmap index=" << bitmapIndex << 
		" region: " << regionX << "," << regionY << 
		" bitmap: " << bitmapX << "," << bitmapY << endl;
	
	if( this->bitmapIndex != bitmapIndex ) {
		char bitmapName[3000];
		sprintf( bitmapName, "/mapgrid/world/map_%02d.png", bitmapIndex );
		cerr << "Needs bitmap " << bitmapName << endl;
		
		if( bitmapSurface ) {
			SDL_FreeSurface( bitmapSurface );
		}

		string fn = rootDir + bitmapName;
		cerr << "Loading bitmap: " << fn << endl;
		if ( !( bitmapSurface = IMG_Load( fn.c_str() ) ) ) {
			cerr << "*** Error loading map chunk (" << fn << "): " << IMG_GetError() << endl;
		}
	}
	
	loadMapGridBitmapRegion();
}

void LandGenerator::loadMapGridBitmapRegion() {
	// select the correct section of the image
	// The raw data of the source image.
	unsigned char * data = ( unsigned char * ) ( bitmapSurface->pixels );
//		for( int i = 0; i < 128 * 128 * BYTES_PER_PIXEL; i+=BYTES_PER_PIXEL ) {
//			fprintf( stderr, "%02x%02x%02x%02x,", data[i], data[i+1], data[i+2], data[i+3]);
//			if( i > 0 && i % ( 128 * BYTES_PER_PIXEL ) == 0 ) cerr << endl;
//		}
//	cerr << "bytesPerPixel: " << bitmapSurface->format->BytesPerPixel <<
//		" bitsPerPixel: " << bitmapSurface->format->BitsPerPixel <<
//		" pitch=" << bitmapSurface->pitch << endl;

	// The destination image (a single tile)
	std::vector<GLubyte> image( REGION_SIZE * REGION_SIZE * BYTES_PER_PIXEL );

	int rx = regionX % REGIONS_PER_BITMAP;
	int ry = regionY % REGIONS_PER_BITMAP;
	int count = 0;
	// where the tile starts in a line
	int offs = rx * REGION_SIZE * BYTES_PER_PIXEL;
	// where the tile ends in a line
	int rest = ( rx + 1 ) * REGION_SIZE * BYTES_PER_PIXEL;
	// Current position in the source data
	int c = offs + ( ry * REGION_SIZE * bitmapSurface->pitch );
	// the following lines extract R,G and B values from any bitmap

//	cerr << " c:" << c << " ";
	for ( int i = 0; i < REGION_SIZE * REGION_SIZE; ++i ) {

		if ( i > 0 && i % REGION_SIZE == 0 ) {
			// skip the rest of the line
			c += ( bitmapSurface->pitch - rest );
			// skip the offset (go to where the tile starts)
			c += offs;
//			cerr << endl;
//			cerr << " c:" << c << " ";
		}

		for ( int p = 0; p < BYTES_PER_PIXEL; p++ ) {
//			fprintf( stderr, "%02x", data[c] );
			image[count++] = data[c++];
		}
//		cerr << ",";
	}
//	cerr << endl << "found " << image.size() << " pixels." << endl;
	//printRGB( &image );
	
	packMapData( image );
}

void LandGenerator::packMapData( std::vector<GLubyte> &image ) {
	unsigned int r, g, b, color;

	for( int i = 0; i < (int)image.size(); i += BYTES_PER_PIXEL ) {
		r = (unsigned int)image[ i ]; g = (unsigned int)image[ i + 1 ]; b = (unsigned int)image[ i + 2 ];
		color = ( r << 16 ) + ( g << 8 ) + b ;

		int d = 0;
		
		// Check red byte (land elevation)
		switch( r ) {
		case 200:
			d |= TERRAIN_MOUNTAINS;
			break;
		case 150:
			d |= TERRAIN_HIGHLANDS;
			break;
		case 100:
			d |= TERRAIN_LOWLANDS;
			break;
		case 50:
			d |= TERRAIN_PLAINS;
			break;
		default:
			d |= TERRAIN_PLAINS;
			break;
		}

		// Black samples are always water.
		if( !color ) d = TERRAIN_WATER;
	
		data[ i / BYTES_PER_PIXEL ] = d;

		vegetation[ i / BYTES_PER_PIXEL ] = g;
		climate[ i / BYTES_PER_PIXEL ] = b;
	}

	cellular->initialize( REGION_SIZE, REGION_SIZE, data, vegetation, climate );
}

void LandGenerator::generate( Map *map, ShapePalette *shapePal ) {
	loadMapGridBitmap();
	
	cellular->generate( true, true, 4, true, false );
	cellular->makeMinSpace( 4 );
	cellular->print();
	
	createGround();
}

void LandGenerator::createGround() {
	// create the undulating ground
	float a,b,f;
	for ( int x = 0; x < QUARTER_WIDTH_IN_NODES; x++ ) {
		for ( int y = 0; y < QUARTER_DEPTH_IN_NODES; y++ ) {
			if ( cellular->getNode( x, y )->elevated || cellular->getNode( x, y )->high ) {
				// smooth hills
				b = 2.0f;
				a = Util::roll( 2.75f, 3.0f );
				f = 8.0f;
			} else {
				// flatland with variations
				b = 1.0f;
				a = Util::roll( 0.25f, 1.0f );
				f = 40.0f / 2 + Util::roll( 0.25f, 40.0f / 2 );
			}
			
			ground[x][y] = b +
			               ( a *
			                 sin( PI / ( 180.0f / static_cast<float>( x * OUTDOORS_STEP * f ) ) ) *
			                 cos( PI / ( 180.0f / static_cast<float>( y * OUTDOORS_STEP  * f ) ) ) );
			if ( ground[x][y] < 0 ) ground[x][y] = 0;
		}
	}
		
	// add some random mountains
	for ( int x = 1; x < QUARTER_WIDTH_IN_NODES; x++ ) {
		for ( int y = 1; y < QUARTER_DEPTH_IN_NODES; y++ ) {
			if ( ( cellular->getNode( x, y )->high && Util::dice( 150 ) < 2 ) || 
					( cellular->getNode( x, y )->elevated && Util::dice( 300 ) < 2 ) ) {
				ground[x][y] = Util::roll( 14.0f, 20.0f );
				ground[x - 1][y] = Util::roll( 14.0f, 20.0f );
				ground[x][y - 1] = Util::roll( 14.0f, 20.0f );
				ground[x - 1][y - 1] = Util::roll( 14.0f, 20.0f );
			}
		}
	}
}

void LandGenerator::printMaze() {
	cellular->print(); 
}

bool LandGenerator::addParty( Map *map, ShapePalette *shapePal, bool goingUp, bool goingDown ) {
	if( willAddParty ) {
		TerrainGenerator::addParty( map, shapePal, goingUp, goingDown );
	}
	return true;
}

/// Initializes the outdoor ground textures. Takes height into account.

void LandGenerator::initOutdoorsGroundTexture( Map *map ) {
	// set ground texture

	std::map<int, int> texturesUsed;

	int ex = MAP_TILES_X;
	int ey = MAP_TILES_Y;
	// ideally the below would be refs[ex][ey] but that won't work in C++... :-(
	GroundTexture *refs[MAP_WIDTH][MAP_DEPTH];
	for ( int x = 0; x < ex; x += OUTDOOR_FLOOR_TEX_SIZE ) {
		for ( int y = 0; y < ey; y += OUTDOOR_FLOOR_TEX_SIZE ) {
			bool high = isRockTexture( map, x, y );
			bool low = isLakebedTexture( map, x, y );
			// if it's both high and low, make rock texture. Otherwise mountain sides will be drawn with lakebed texture.
			string name = high ? "rock" : ( low ? "lakebed" : "grass" );
			GroundTexture *gt = map->getShapes()->getGroundTexture( name );
			if( gt ) {
				Texture tex = gt->getRandomTexture();
				for ( int xx = 0; xx < OUTDOOR_FLOOR_TEX_SIZE; xx++ ) {
					for ( int yy = 0; yy < OUTDOOR_FLOOR_TEX_SIZE; yy++ ) {
						refs[x + xx][y + yy] = gt;
						map->setGroundTex( x + xx, y + yy, tex );
					}
				}
			}
		}
	}

	for ( int x = OUTDOOR_FLOOR_TEX_SIZE; x < ex - OUTDOOR_FLOOR_TEX_SIZE; x += OUTDOOR_FLOOR_TEX_SIZE ) {
		for ( int y = OUTDOOR_FLOOR_TEX_SIZE; y < ey - OUTDOOR_FLOOR_TEX_SIZE; y += OUTDOOR_FLOOR_TEX_SIZE ) {
			bool w = refs[x - OUTDOOR_FLOOR_TEX_SIZE][y] == refs[x][y] ? true : false;
			bool e = refs[x + OUTDOOR_FLOOR_TEX_SIZE][y] == refs[x][y] ? true : false;
			bool s = refs[x][y + OUTDOOR_FLOOR_TEX_SIZE] == refs[x][y] ? true : false;
			bool n = refs[x][y - OUTDOOR_FLOOR_TEX_SIZE] == refs[x][y] ? true : false;
			if ( !( w && e && s && n ) ) {
				applyGrassEdges( map, x, y, w, e, s, n );
			}
		}
	}

	addHighVariation( map, WallTheme::OUTDOOR_THEME_REF_SNOW, GROUND_LAYER );
	addHighVariation( map, WallTheme::OUTDOOR_THEME_REF_SNOW_BIG, GROUND_LAYER );

}

/// Sets up a smoothly blended grass edge.

/// It takes a couple of parameters: The x,y map position and four parameters
/// that specify in which direction(s) to apply the blending.

void LandGenerator::applyGrassEdges( Map *map, int x, int y, bool w, bool e, bool s, bool n ) {
	int angle = 0;
	int sx = x;
	int sy = y + 1 + OUTDOOR_FLOOR_TEX_SIZE;
	int ref = -1;
	if ( !w && !s && !e ) {
		angle = 180;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_TIP;
	} else if ( !e && !s && !n ) {
		angle = 270;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_TIP;
	} else if ( !e && !n && !w ) {
		angle = 0;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_TIP;
	} else if ( !w && !n && !s ) {
		angle = 90;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_TIP;

	} else if ( !w && !e ) {
		angle = 0;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_NARROW;
	} else if ( !n && !s ) {
		angle = 90;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_NARROW;

	} else if ( !w && !s ) {
		angle = 90;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_CORNER;
	} else if ( !e && !s ) {
		angle = 180;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_CORNER;
	} else if ( !e && !n ) {
		angle = 270;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_CORNER;
	} else if ( !w && !n ) {
		angle = 0;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_CORNER;

	} else if ( !e ) {
		angle = 180;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_EDGE;
	} else if ( !w ) {
		angle = 0;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_EDGE;
	} else if ( !n ) {
		angle = 270;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_EDGE;
	} else if ( !s ) {
		angle = 90;
		ref = WallTheme::OUTDOOR_THEME_REF_GRASS_EDGE;
	}

	if ( ref > -1 ) {
		map->setOutdoorTexture( sx * OUTDOORS_STEP, sy * OUTDOORS_STEP, 0, 0, ref, angle, false, false, GROUND_LAYER );
	}
}

/// Returns a random variation of the outdoor texture specified by ref.

Texture LandGenerator::getThemeTex( Map *map, int ref ) {
	int faceCount = map->getShapes()->getCurrentTheme()->getOutdoorFaceCount( ref );
	Texture* textureGroup = map->getShapes()->getCurrentTheme()->getOutdoorTextureGroup( ref );
	return textureGroup[ Util::dice( faceCount ) ];
}

/// Adds semi-random height variation to an outdoor map.

/// Higher parts of the map are randomly selected, their height value
/// set to z and textured with the referenced theme specific texture.

void LandGenerator::addHighVariation( Map *map, int ref, int z ) {
	int width = map->getShapes()->getCurrentTheme()->getOutdoorTextureWidth( ref );
	int height = map->getShapes()->getCurrentTheme()->getOutdoorTextureHeight( ref );
	int outdoor_w = width / OUTDOORS_STEP;
	int outdoor_h = height / OUTDOORS_STEP;
	int ex = MAP_TILES_X;
	int ey = MAP_TILES_Y;
	for ( int x = 0; x < ex; x += outdoor_w ) {
		for ( int y = 0; y < ey; y += outdoor_h ) {
			if ( isAllHigh( map, x, y, outdoor_w, outdoor_h ) && !Util::dice( 10 ) && !map->hasOutdoorTexture( x, y, width, height ) ) {
				map->setOutdoorTexture( x * OUTDOORS_STEP, ( y + outdoor_h + 1 ) * OUTDOORS_STEP,
				                        0, 0, ref, Util::dice( 4 ) * 90.0f, false, false, z );
			}
		}
	}
}

/// Should a rock texture be applied to this map position due to its height?

bool LandGenerator::isRockTexture( Map *map, int x, int y ) {
	bool high = false;
	for ( int xx = 0; xx < OUTDOOR_FLOOR_TEX_SIZE + 1; xx++ ) {
		for ( int yy = 0; yy < OUTDOOR_FLOOR_TEX_SIZE + 1; yy++ ) {
			if ( map->getGroundHeight( x + xx, y + yy ) > 10 ) {
				high = true;
				break;
			}
		}
	}
	return high;
}


bool LandGenerator::isLakebedTexture( Map *map, int x, int y ) {
	bool low = false;
	for ( int xx = 0; xx < OUTDOOR_FLOOR_TEX_SIZE + 1; xx++ ) {
		for ( int yy = 0; yy < OUTDOOR_FLOOR_TEX_SIZE + 1; yy++ ) {
			if ( map->getGroundHeight( x + xx, y + yy ) < -10 ) {
				low = true;
				break;
			}
		}
	}
	return low;
}

/// Are all map tiles in the specified area high above "sea level"?

bool LandGenerator::isAllHigh( Map *map, int x, int y, int w, int h ) {
	bool high = true;
	for ( int xx = 0; xx < w + 1; xx++ ) {
		for ( int yy = 0; yy < h + 1; yy++ ) {
			if ( map->getGroundHeight( x + xx, y + yy ) < 10 ) {
				high = false;
				break;
			}
		}
	}
	return high;
}