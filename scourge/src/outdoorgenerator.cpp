/***************************************************************************
                outdoorgenerator.cpp  -  Generates outdoor maps
                             -------------------
    begin                : Sat May 12 2007
    copyright            : (C) 2007 by Gabor Torok
    email                : cctorok@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
#include "common/constants.h"
#include "outdoorgenerator.h"
#include "render/map.h"
#include "shapepalette.h"
#include "scourge.h"
#include "board.h"
#include "render/maprender.h"
#include "render/maprenderhelper.h"
#include "render/glshape.h"
#include "render/virtualshape.h"
#include "cellular.h"
#include "sqbinding/sqbinding.h"
#include "rpg/rpglib.h"
#include "creature.h"
#include <vector>

using namespace std;


//good little mountain for turning into lake
#define SMALL_MOUNTAIN 120

#define VILLAGE_WIDTH 15
#define VILLAGE_HEIGHT 15

/**
 * The outdoors is generated by connecting four cellular-automaton-created maps.
 * If we were to draw one big map, the recursions for finding free space take too
 * long.
 */
OutdoorGenerator::OutdoorGenerator( Scourge *scourge, int level, int depth, int maxDepth,
    bool stairsDown, bool stairsUp,
    Mission *mission ) :
		TerrainGenerator( scourge, level, depth, maxDepth, stairsDown, stairsUp, mission, 13 ) {
	// init the ground
	for ( int x = 0; x < OUTDOOR_MAP_STEP_WIDTH; x++ ) {
		for ( int y = 0; y < OUTDOOR_MAP_STEP_DEPTH; y++ ) {
			ground[x][y] = 0; //XXX: ?initializes ground[MAP_WIDTH][MAP_DEPTH] only partially
		}
	}
	this->cellular[0][0] = new CellularAutomaton( OUTDOOR_WIDTH_IN_NODES, OUTDOOR_DEPTH_IN_NODES );
	this->cellular[1][0] = new CellularAutomaton( OUTDOOR_WIDTH_IN_NODES, OUTDOOR_DEPTH_IN_NODES );
	this->cellular[0][1] = new CellularAutomaton( OUTDOOR_WIDTH_IN_NODES, OUTDOOR_DEPTH_IN_NODES );
	this->cellular[1][1] = new CellularAutomaton( OUTDOOR_WIDTH_IN_NODES, OUTDOOR_DEPTH_IN_NODES );
	roadX = roadY = MAP_OFFSET + MAP_UNIT;
}

OutdoorGenerator::~OutdoorGenerator() {
	delete cellular[0][0];
	delete cellular[0][1];
	delete cellular[1][0];
	delete cellular[1][1];
}


OutdoorGenerator::AroundMapLooker seen; //we may make it static member?

// How many spaces does this mountain take up? Refactored to burn stack lot less.
int OutdoorGenerator::getMountainSize( int x, int y, Map *map, AroundMapLooker& lake ) {
	int ret( 0 );
	// the cases we look at something not worth looking at
	if ( x < 0
	        || x >= OUTDOOR_MAP_STEP_WIDTH
	        || y < 0
	        || y >= OUTDOOR_MAP_STEP_DEPTH
	        || map->getGroundHeight( x, y ) < 10
	        || seen.at( x, y ) ) return ret;
	// look up everything west
	bool mountainAhead;
	int lookWest( x );
	do {
		++ret;
		seen.at( lookWest, y ) = true;
		lake.at( lookWest, y ) = true;
		--lookWest;
		mountainAhead = ( lookWest >= 0 )
		                && ( map->getGroundHeight( lookWest, y ) >= 10 );
	} while ( mountainAhead );
	// look up everything east
	int lookEast( x );
	do {
		// "if" for avoiding taking account spot at x,y twice
		if ( !seen.at( lookEast, y ) ) ++ret;
		seen.at( lookEast, y ) = true;
		lake.at( lookEast, y ) = true;
		++lookEast;
		mountainAhead = ( lookEast < OUTDOOR_MAP_STEP_WIDTH )
		                && ( map->getGroundHeight( lookEast, y ) >= 10 );
	} while ( mountainAhead );
	// look up north and south too
	for ( int lookX = lookWest; lookX <= lookEast; lookX++ ) {
		ret += getMountainSize( lookX, y - 1, map, lake );
		ret += getMountainSize( lookX, y + 1, map, lake );
	}
	return ret;
}

bool OutdoorGenerator::drawNodes( Map *map, ShapePalette *shapePal ) {

	updateStatus( _( "Loading theme" ) );
	//if ( map->getPreferences()->isDebugTheme() ) shapePal->loadDebugTheme();
	//else shapePal->loadRandomOutdoorTheme();

	map->setHeightMapEnabled( true );

	// add mountains
	int offs = MAP_OFFSET / OUTDOORS_STEP;
	for ( int x = 0; x < OUTDOOR_MAP_STEP_WIDTH; x++ ) {
		for ( int y = 0; y < OUTDOOR_MAP_STEP_DEPTH; y++ ) {
			map->setGroundHeight( x, y, ground[x][y] );
			if ( x >= offs && x < 2 * OUTDOOR_WIDTH_IN_NODES + offs &&
			        y >= offs && y < 2 * OUTDOOR_DEPTH_IN_NODES + offs ) {
				int cx = ( x - offs ) / OUTDOOR_WIDTH_IN_NODES;
				int cy = ( y - offs ) / OUTDOOR_DEPTH_IN_NODES;
				int mx = ( x - offs ) % OUTDOOR_WIDTH_IN_NODES;
				int my = ( y - offs ) % OUTDOOR_DEPTH_IN_NODES;
				if ( cellular[ cx ][ cy ]->getNode( mx, my )->wall ) {
					map->setGroundHeight( x, y, Util::roll( 14.0f, 20.0f ) );
				}
			} else {
				map->setGroundHeight( x, y, Util::roll( 14.0f, 20.0f ) );
			}
		}
	}

	// turn some mountains into lakes
	seen.clear();
	for ( int x = 0; x < OUTDOOR_MAP_STEP_WIDTH; x++ ) {
		for ( int y = 0; y < OUTDOOR_MAP_STEP_DEPTH; y++ ) {
			AroundMapLooker lake;
			int size = getMountainSize( x, y, map, lake );
			if ( size > 0 && size < SMALL_MOUNTAIN ) {
				if ( 0 == Util::dice( 2 ) ) {
					for ( int posX = 0; posX < OUTDOOR_MAP_STEP_WIDTH; ++posX ) {
						for ( int posY = 0; posY < OUTDOOR_MAP_STEP_DEPTH; ++posY ) {
							if ( lake.at( posX, posY ) )
								map->setGroundHeight( posX, posY, -( map->getGroundHeight( posX, posY ) ) );
						}
					}
				}
			}
		}
	}

	// add a village
	int villageX, villageY;
	addVillage( map, shapePal, &villageX, &villageY );

	// add trees
	for ( int x = 0; x < OUTDOOR_MAP_STEP_WIDTH; x++ ) {
		for ( int y = 0; y < OUTDOOR_MAP_STEP_DEPTH; y++ ) {
			if ( x >= offs && x < 2 * OUTDOOR_WIDTH_IN_NODES + offs &&
			        y >= offs && y < 2 * OUTDOOR_DEPTH_IN_NODES + offs ) {
				int cx = ( x - offs ) / OUTDOOR_WIDTH_IN_NODES;
				int cy = ( y - offs ) / OUTDOOR_DEPTH_IN_NODES;
				int mx = ( x - offs ) % OUTDOOR_WIDTH_IN_NODES;
				int my = ( y - offs ) % OUTDOOR_DEPTH_IN_NODES;
				if ( cellular[ cx ][ cy ]->getNode( mx, my )->island ) {
					GLShape *shape = shapePal->getRandomTreeShape( shapePal );
					int xx = x * OUTDOORS_STEP;
					int yy = y * OUTDOORS_STEP + shape->getHeight();

					// don't put them on roads and in houses
					if ( !( xx >= villageX && xx < villageX + VILLAGE_WIDTH * MAP_UNIT &&
							yy >= villageY && yy < villageY + VILLAGE_HEIGHT ) && 
							map->shapeFitsOutdoors( shape, xx, yy, 0 ) ) {
						map->setPosition( xx, yy, 0, shape );
					}
				}
			}
		}
	}

//	map->getRender()->initOutdoorsGroundTexture();

	// create a set of rooms for outdoor items
	doorCount = 0;
	roomCount = 0;
	for ( int cx = 0; cx < 2; cx++ ) {
		for ( int cy = 0; cy < 2; cy++ ) {
			//CellularAutomaton *c = cellular[cx][cy];
			room[ roomCount ].x = offset + ( cx * OUTDOOR_WIDTH_IN_NODES * OUTDOORS_STEP );
			room[ roomCount ].y = offset + ( cy * OUTDOOR_DEPTH_IN_NODES * OUTDOORS_STEP );
			room[ roomCount ].w = OUTDOOR_WIDTH_IN_NODES * OUTDOORS_STEP;
			room[ roomCount ].h = OUTDOOR_DEPTH_IN_NODES * OUTDOORS_STEP;
			room[ roomCount ].valueBonus = 0;
			roomCount++;
		}
	}
	roomMaxWidth = 0;
	roomMaxHeight = 0;
	objectCount = 7 + ( level / 8 ) * 5;
	monsters = true;

	// set the floor, so random positioning works in terrain generator
	// a bit of a song-and-dance with keepFloor is so that random objects aren't placed in rooms
	for ( int x = MAP_OFFSET; x < MAP_WIDTH - MAP_OFFSET; x += MAP_UNIT ) {
		for ( int y = MAP_OFFSET; y < MAP_DEPTH - MAP_OFFSET - MAP_UNIT; y += MAP_UNIT ) {
			if ( keepFloor.find( x + MAP_WIDTH * y ) != keepFloor.end() ) {
				map->removeFloorPosition( ( Sint16 )x, ( Sint16 )y + MAP_UNIT );
			} else {
				map->setFloorPosition( ( Sint16 )x, ( Sint16 )y + MAP_UNIT, ( Shape* )shapePal->findShapeByName( "FLOOR_TILE" ) );
			}
		}
	}

	// event handler for custom map processing
	if ( !scourge->getSession()->getMap()->inMapEditor() ) {
		scourge->getSession()->getSquirrel()->callMapMethod( "outdoorMapCompleted", map->getName() );
	}

	return true;
}

// make sure we're not inside a house
bool OutdoorGenerator::isShapeOnFloor( Shape *shape, int x, int y, Map *map ) {
	int cx = x + shape->getWidth() / 2;
	int cy = y - shape->getDepth() / 2;
	for ( int xx = cx - 3 * MAP_UNIT; xx < cx + 3 * MAP_UNIT; xx++ ) {
		for ( int yy = cy - 3 * MAP_UNIT; yy < cy + 3 * MAP_UNIT; yy++ ) {
			if ( xx < 0 || yy < 0 || xx >= MAP_WIDTH || yy >= MAP_DEPTH ) {
				continue;
			}
			Location *pos = map->getLocation( xx, yy, 0 );
			if ( pos && pos->shape ) {
				Shape *other = pos->shape->isVirtual() ? ( ( VirtualShape* )pos->shape )->getRef() : pos->shape;
				if ( scourge->getSDLHandler()->intersects( x, y, shape->getWidth(), shape->getDepth(),
				        xx, yy, other->getWidth(), other->getDepth() ) ) {
					return true;
				}
			}
		}
	}
	return false;
}

// start party in the middle of the cross-roads
void OutdoorGenerator::getPartyStartingLocation( int *xx, int *yy ) {
	*xx = roadX;
	*yy = roadY;
}

void OutdoorGenerator::addVillage( Map *map, ShapePalette *shapePal, int *villageX, int *villageY ) {
	int x = MAP_OFFSET + ( ( Util::dice( MAP_WIDTH - ( MAP_OFFSET * 4 ) - VILLAGE_WIDTH ) / MAP_UNIT ) * MAP_UNIT );
	int y = MAP_OFFSET + ( ( Util::dice( MAP_DEPTH - ( MAP_OFFSET * 4 ) - VILLAGE_HEIGHT ) / MAP_UNIT ) * MAP_UNIT );

	removeLakes( map, x, y );

	createRoads( map, shapePal, x, y );
	
	createHouses( map, shapePal, x, y );
	
	*villageX = x;
	*villageY = y;
}

void OutdoorGenerator::addNpcs( Map *map, ShapePalette *shapePal, int villageX, int villageY, int villageWidth, int villageHeight ) {
	for ( int i = 0; i < 10; i++ ) {
		createNpc( map, shapePal,
		           Util::pickOne( villageX, villageX + villageWidth ),
		           Util::pickOne( villageY, villageY + villageHeight ) );
	}
	for ( int i = 0; i < roomCount; i++ ) {
		createNpc( map, shapePal,
		           ( room[ i ].x + room[ i ].w / 2 ),
		           ( room[ i ].y + room[ i ].h / 2 ) );
	}
}

void OutdoorGenerator::createNpc( Map *map, ShapePalette *shapePal, int x, int y ) {
	Monster *npc;
	char npcName[255];
	shapePal->getSession()->getSquirrel()->callNoArgStringReturnMethod( "getVillageNpcType", npcName );
	if ( !strlen( npcName ) ) {
		cerr << "*** getVillageNpcType from squirrel returned no npc name." << endl;
		return;
	} else {
		npc = Monster::getMonsterByName( npcName );
		if ( !npc ) {
			cerr << "*** Can't find npc: " << npcName << endl;
			return;
		} else if ( !npc->isNpc() ) {
			cerr << "*** Can't find npc: " << npcName << endl;
			return;
		}
	}

	GLShape *shape = scourge->getShapePalette()->getCreatureShape( npc->getModelName(), npc->getSkinName(), npc->getScale(), npc );
	Creature *creature = scourge->getSession()->newCreature( npc, shape );
	int fx, fy;
	creature->findPlace( x, y, &fx, &fy );

	if ( 0 == Util::dice( 3 ) ) {
		Mission::createTypedNpc( creature, level, fx, fy );
	}
}

// roads and lakes don't mix well
void OutdoorGenerator::removeLakes( Map *map, int x, int y ) {
	for ( int vx = x; vx < x + VILLAGE_WIDTH * MAP_UNIT; vx++ ) {
		for ( int vy = y; vy < y + VILLAGE_HEIGHT * MAP_UNIT; vy++ ) {
			map->flattenChunk( vx, vy, Util::roll( 0, 1 ) );
		}
	}
}

#define HOUSE_SHAPES_SIZE 3
int HOUSE_SHAPES[][2] = { { 2, 2 }, { 2, 3 }, { 3, 2 } };
void OutdoorGenerator::createHouses( Map *map, ShapePalette *shapePal, int x, int y ) {
	int coords[4];
	coords[0] = x;
	coords[1] = y;
	coords[2] = VILLAGE_WIDTH;
	coords[3] = VILLAGE_HEIGHT;
	shapePal->getSession()->getSquirrel()->callIntArgMethod( "drawVillage", 4, coords );
	
	//Êany floors created should be kept
	for( int vx = 0; vx < VILLAGE_WIDTH; vx++ ) {
		for( int vy = 0; vy < VILLAGE_HEIGHT; vy++ ) {
			int hx = x + vx * MAP_UNIT;
			int hy = y + vy * MAP_UNIT;
			Shape *shape = map->getFloorPosition( hx, hy );
			if( shape ) {
				keepFloor[ hx + MAP_WIDTH * hy ] = (GLShape*)shape;
			}
		}
	}		
}

void OutdoorGenerator::createRoads( Map *map, ShapePalette *shapePal, int x, int y ) {
	for( int yy = 4; yy <= VILLAGE_HEIGHT; yy += 4 ) {
		int vy = y + ( yy * MAP_UNIT );
		for ( int i = 0; i < VILLAGE_WIDTH; i++ ) {
			int vx = x + ( i * MAP_UNIT );
			if ( i == 0 ) {
				map->addOutdoorTexture( vx, vy, "street_end" );
			} else if ( i >= VILLAGE_WIDTH - 1 ) {
				map->addOutdoorTexture( vx, vy, "street_end_180", 0 );
			} else {
				map->addOutdoorTexture( vx, vy, "street" );
			}
		}
	}
	bool foundCrossRoad = false;
	for( int xx = 3; xx <= VILLAGE_WIDTH - 1; xx += 4 ) {
		int vx = x + ( xx * MAP_UNIT );
		for ( int i = 1; i <= VILLAGE_HEIGHT; i++ ) {
			int vy = y + ( i * MAP_UNIT );
			if ( i == 1 ) {
				map->addOutdoorTexture( vx, vy, "street_end_270" );
			} else if ( i % 4 == 0 ) {
				map->addOutdoorTexture( vx, vy, "street_cross" );
				if( !foundCrossRoad ) {
					// needed for party start location
					roadX = vx + MAP_UNIT / 2;
					roadY = vy - MAP_UNIT / 2;
					foundCrossRoad = true;
				}
			} else if ( i >= VILLAGE_HEIGHT  ) {
				map->addOutdoorTexture( vx, vy, "street_end_90", 0 );
			} else {
				map->addOutdoorTexture( vx, vy, "street_90" );
			}
		}
	}	
}

MapRenderHelper* OutdoorGenerator::getMapRenderHelper() {
	// we need fog
	return MapRenderHelper::helpers[ MapRenderHelper::OUTDOOR_HELPER ];
	//return MapRenderHelper::helpers[ MapRenderHelper::DEBUG_OUTDOOR_HELPER ];
}

// =====================================================
// =====================================================
// generation
//
void OutdoorGenerator::generate( Map *map, ShapePalette *shapePal ) {
	cellular[0][0]->generate( true, true, 4 );
	cellular[0][0]->makeAccessible( OUTDOOR_WIDTH_IN_NODES - 1, OUTDOOR_DEPTH_IN_NODES / 2 );
	cellular[0][0]->makeAccessible( OUTDOOR_WIDTH_IN_NODES / 2, OUTDOOR_DEPTH_IN_NODES - 1 );
	cellular[0][0]->makeMinSpace( 4 );
	//cellular[0][0]->print();

	cellular[1][0]->generate( true, true, 4 );
	cellular[1][0]->makeAccessible( 0, OUTDOOR_DEPTH_IN_NODES / 2 );
	cellular[1][0]->makeAccessible( OUTDOOR_WIDTH_IN_NODES / 2, OUTDOOR_DEPTH_IN_NODES - 1 );
	cellular[1][0]->makeMinSpace( 4 );
	//cellular[1][0]->print();

	cellular[0][1]->generate( true, true, 4 );
	cellular[0][1]->makeAccessible( OUTDOOR_WIDTH_IN_NODES - 1, OUTDOOR_DEPTH_IN_NODES / 2 );
	cellular[0][1]->makeAccessible( OUTDOOR_WIDTH_IN_NODES / 2, 0 );
	cellular[0][1]->makeMinSpace( 4 );
	//cellular[0][1]->print();

	cellular[1][1]->generate( true, true, 4 );
	cellular[1][1]->makeAccessible( 0, OUTDOOR_DEPTH_IN_NODES / 2 );
	cellular[1][1]->makeAccessible( OUTDOOR_WIDTH_IN_NODES / 2, 0 );
	cellular[1][1]->makeMinSpace( 4 );
	//cellular[1][1]->print();
	
	createGround();
}

void OutdoorGenerator::createGround() {
	// create the undulating ground
	float amp = 1.0f;
	float freq = 40.0f;
	for ( int x = 0; x < OUTDOOR_MAP_STEP_WIDTH; x++ ) {
		for ( int y = 0; y < OUTDOOR_MAP_STEP_DEPTH; y++ ) {
			// fixme: use a more sinoid function here
			// ground[x][y] = ( 1.0f * rand() / RAND_MAX );
			float a = Util::roll( 0.25f, amp );
			float f = freq / 2 + Util::roll( 0.25f, freq / 2 );
			ground[x][y] = a +
			               ( a *
			                 sin( PI / ( 180.0f / static_cast<float>( x * OUTDOORS_STEP * f ) ) ) *
			                 cos( PI / ( 180.0f / static_cast<float>( y * OUTDOORS_STEP  * f ) ) ) );
			if ( ground[x][y] < 0 ) ground[x][y] = 0;
		}
	}
}

void OutdoorGenerator::addFurniture( Map *map, ShapePalette *shapePal ) {
}

void OutdoorGenerator::addContainers( Map *map, ShapePalette *shapePal ) {
}

void OutdoorGenerator::lockDoors( Map *map, ShapePalette *shapePal ) {
	// don't lock anything
}

void OutdoorGenerator::addMonsters( Map *levelMap, ShapePalette *shapePal ) {
	// add a few misc. monsters in the corridors (use objectCount to approx. number of wandering monsters)
	for ( int i = 0; i < objectCount; i++ ) {
		Monster *monster = Monster::getRandomMonster( getBaseMonsterLevel() );
		if ( !monster ) {
			cerr << "Warning: no monsters defined for level: " << level << endl;
			break;
		}
		GLShape *shape =
		  scourge->getShapePalette()->getCreatureShape( monster->getModelName(),
		      monster->getSkinName(),
		      monster->getScale(),
		      monster );
		Creature *creature = scourge->getSession()->newCreature( monster, shape );
		cerr << "Added monster " << monster->getType() << endl;
		int x, y;
		getRandomLocation( levelMap, creature->getShape(), &x, &y );
		addItem( levelMap, creature, NULL, NULL, x, y );
		creature->moveTo( x, y, 0 );
	}
}

void OutdoorGenerator::printMaze() {
	for ( int x = 0; x < 2; x++ ) {
		for ( int y = 0; y < 2; y++ ) {
			cerr << "x=" << x << " y=" << y << endl;
			cellular[x][y]->print();
		}
	}
}
/*
void OutdoorGenerator::addRugs( Map *map, ShapePalette *shapePal ) {
     // no rugs
}
*/
void OutdoorGenerator::addTraps( Map *map, ShapePalette *shapePal ) {
	// no traps
}

void OutdoorGenerator::deleteFreeSpaceMap( Map *map, ShapePalette *shapePal ) {
	TerrainGenerator::deleteFreeSpaceMap( map, shapePal );
	// remove the floor
	for ( int x = MAP_OFFSET; x < MAP_WIDTH - MAP_OFFSET; x += MAP_UNIT ) {
		for ( int y = MAP_OFFSET; y < MAP_DEPTH - MAP_OFFSET; y += MAP_UNIT ) {
			if ( keepFloor.find( x + MAP_WIDTH * y ) != keepFloor.end() ) {
				map->setFloorPosition( ( Sint16 )x, ( Sint16 )y + MAP_UNIT, keepFloor[ x + MAP_WIDTH * y ] );
			} else {
				map->removeFloorPosition( ( Sint16 )x, ( Sint16 )y + MAP_UNIT );
			}
		}
	}
}
